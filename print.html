<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust In Detail</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><div>Rust in detail</div></li><li class="chapter-item expanded affix "><a href="Prefix/what_is_this_book.html">What is this book</a></li><li class="chapter-item expanded "><a href="ch01/intro_anatomy.html"><strong aria-hidden="true">1.</strong> Anatomy of a Rust Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01/overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="ch01/exec.html"><strong aria-hidden="true">1.2.</strong> Run</a></li><li class="chapter-item expanded "><a href="ch01/constant.html"><strong aria-hidden="true">1.3.</strong> Constant</a></li><li class="chapter-item expanded "><a href="ch01/statics.html"><strong aria-hidden="true">1.4.</strong> Statics</a></li><li class="chapter-item expanded "><a href="ch01/stack.html"><strong aria-hidden="true">1.5.</strong> Stack</a></li><li class="chapter-item expanded "><a href="ch01/heap.html"><strong aria-hidden="true">1.6.</strong> Heap</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.7.</strong> Registers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.8.</strong> Complications, closures , red zone, scratch pad</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.9.</strong> &amp;str vs String</div></li><li class="chapter-item expanded "><a href="ch01/function_calls.html"><strong aria-hidden="true">1.10.</strong> Function calls, ABIs</a></li><li class="chapter-item expanded "><a href="ch01/hardware_vs_compiler.html"><strong aria-hidden="true">1.11.</strong> hardware vs compiler</a></li></ol></li><li class="chapter-item expanded "><a href="ch02/intro_lifetimes.html"><strong aria-hidden="true">2.</strong> Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.</strong> Rules</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> How rustc does borrow checking</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> Lifetimes in type signatures</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> initialzing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.5.</strong> splitting borrows</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.6.</strong> Phantom data</div></li></ol></li><li class="chapter-item expanded "><a href="ch03/intro_unsafe.html"><strong aria-hidden="true">3.</strong> Unsafe</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Undefined behaviour</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> valid data</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Unsafe functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Implications</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Traits</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> ptrs vs references</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.7.</strong> Examples</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.8.</strong> FFIs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.9.</strong> Allocator</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> unbound lifetime</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.11.</strong> unititalized Maemory radje blog</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.12.</strong> transmute</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.13.</strong> Unsafe tips</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.14.</strong> Casts</div></li></ol></li><li class="chapter-item expanded "><a href="ch04/intro_types.html"><strong aria-hidden="true">4.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> repr</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Intresting Type stuff</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Chalk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> !</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Function Pointers vs Function Items</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Print type sizes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> extern types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> ZSTs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.9.</strong> Empty Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.10.</strong> Thin wrapper</div></li></ol></li><li class="chapter-item expanded "><a href="ch05/intro_type_sizedness.html"><strong aria-hidden="true">5.</strong> Type sizedness</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> &amp;[]</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Pointer and size</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> dyn type</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> DSTs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Heap vs Stack</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> ?sized</div></li></ol></li><li class="chapter-item expanded "><a href="ch06/intro_concur.html"><strong aria-hidden="true">6.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="ch07/intro_async.html"><strong aria-hidden="true">7.</strong> async</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Pin</div></li></ol></li><li class="chapter-item expanded "><a href="ch08/intro_FFIs.html"><strong aria-hidden="true">8.</strong> FFIs</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> C types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Helpful tools</div></li></ol></li><li class="chapter-item expanded "><a href="ch09/intro_miri.html"><strong aria-hidden="true">9.</strong> miri</a></li><li class="chapter-item expanded "><a href="ch10/intro_const_eval.html"><strong aria-hidden="true">10.</strong> constant eval</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> miri</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> Floating point inaccuracies</div></li></ol></li><li class="chapter-item expanded "><a href="ch11/intro_iterators.html"><strong aria-hidden="true">11.</strong> Iterators</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> traits</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.2.</strong> intro_iter() vs iter() bs iter_mut()</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.3.</strong> Other iterator traits</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.4.</strong> Stream iterator</div></li></ol></li><li class="chapter-item expanded "><a href="ch12/intro_generics.html"><strong aria-hidden="true">12.</strong> Generics</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Const Generics</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> Generic Associated Types</div></li></ol></li><li class="chapter-item expanded "><a href="ch13/intro_high_kind.html"><strong aria-hidden="true">13.</strong> Higher kindeness</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.1.</strong> Intro</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.</strong> Generic Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.3.</strong> Lifetimes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.4.</strong> Traits</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.5.</strong> HRTBs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.6.</strong> Const Generics</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.7.</strong> Generic Associated Types</div></li></ol></li><li class="chapter-item expanded "><a href="ch14/intro_cows.html"><strong aria-hidden="true">14.</strong> Cows</a></li><li class="chapter-item expanded "><a href="ch15/intro_heap.html"><strong aria-hidden="true">15.</strong> Heap</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Allocator</div></li></ol></li><li class="chapter-item expanded "><a href="ch16/intro_impl_box.html"><strong aria-hidden="true">16.</strong> Implement Box</a></li><li class="chapter-item expanded "><a href="ch17/intro_impl_vec.html"><strong aria-hidden="true">17.</strong> Implement Vec</a></li><li class="chapter-item expanded "><a href="ch18/intro_inter_mut.html"><strong aria-hidden="true">18.</strong> Interior Mutability</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">18.1.</strong> Exterior vs Interior mutability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.2.</strong> Unsafe_cell</div></li></ol></li><li class="chapter-item expanded "><a href="ch19/intro_impl_cell.html"><strong aria-hidden="true">19.</strong> Implement Cell</a></li><li class="chapter-item expanded "><a href="ch20/intro_impl_rc.html"><strong aria-hidden="true">20.</strong> Implement Rc</a></li><li class="chapter-item expanded "><a href="ch21/intro_impl_refcell.html"><strong aria-hidden="true">21.</strong> Implement Refcell</a></li><li class="chapter-item expanded "><a href="ch22/intro_impl_mutex.html"><strong aria-hidden="true">22.</strong> Implement Mutex</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch22/impl_mutex_initial_layout.html"><strong aria-hidden="true">22.1.</strong> Creating an Initial Layout</a></li><li class="chapter-item expanded "><a href="ch22/impl_mutex_guard.html"><strong aria-hidden="true">22.2.</strong> Implementing MutexGuard</a></li><li class="chapter-item expanded "><a href="ch22/impl_mutex_unsafe_cell.html"><strong aria-hidden="true">22.3.</strong> The UnsafeCell type</a></li><li class="chapter-item expanded "><a href="ch22/impl_mutex_locking.html"><strong aria-hidden="true">22.4.</strong> Implementing locking for our Mutex</a></li><li class="chapter-item expanded "><a href="ch22/impl_mutex_auto_traits.html"><strong aria-hidden="true">22.5.</strong> Should our mutex be ?Sized, Sync, Send</a></li><li class="chapter-item expanded "><a href="ch22/impl_mutex_review_no_poison.html"><strong aria-hidden="true">22.6.</strong> A fully working Mutex</a></li><li class="chapter-item expanded "><a href="ch22/impl_mutex_poison.html"><strong aria-hidden="true">22.7.</strong> Poisoning in our Mutex</a></li><li class="chapter-item expanded "><a href="ch22/impl_mutex_poison_error.html"><strong aria-hidden="true">22.8.</strong> Managing what happens when poisoning occurs</a></li><li class="chapter-item expanded "><a href="ch22/impl_mutex_final.html"><strong aria-hidden="true">22.9.</strong> A working Mutex With poisoning</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.10.</strong> Manually Drop</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Rust Issues</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">23.1.</strong> How to read</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Future Rust Improvements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Undefined behavior</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Conventions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Macros</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> std interesting stuff</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Beneath std</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">29.1.</strong> Setup to program</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.2.</strong> PHil OS stuff raised</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.3.</strong> ABIs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.4.</strong> Red_zone</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.5.</strong> inline</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.</strong> rustc tour</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">30.1.</strong> lang items</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.2.</strong> librification</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.3.</strong> NLL vs polonius</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.4.</strong> datalog language used for polonius</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.5.</strong> trait type checker</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.6.</strong> llvm</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">31.</strong> Formal proof checked stuff</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">31.1.</strong> Stacked borrows</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.</strong> Closure</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">32.1.</strong> syntatic sugar</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.2.</strong> move</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.3.</strong> Fn, FnMut, FnOnce</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.4.</strong> threads</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.</strong> Intresting traits</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">33.1.</strong> From and Into</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.2.</strong> Borrow</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.3.</strong> Borrow_mut</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.4.</strong> As_ref</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.</strong> Intresting Crates</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">34.1.</strong> Nom</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.2.</strong> Serde</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">35.</strong> Blogs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">36.</strong> Coding Challenges</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.</strong> Appendix</div></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Rust In Detail</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-this-book"><a class="header" href="#what-is-this-book">What is this book</a></h1>
<p>This book is my attempt to write down all the </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-rust-program"><a class="header" href="#anatomy-of-a-rust-program">Anatomy of a rust program</a></h1>
<p>In order to understand the more complex aspects of rust we must first analyse the different parts of a compiled rust program. By evaluating the capabilites and limitations of the compiled program we will be able to understand how the complex aspects of rust work and why they are needed.</p>
<p>A rust program can be thought about in five sections: TODO check Execution, Constant, Statics, Stack, Heap</p>
<p>In this chapter we will explore each section why we have them and why we don't have any other sections. Once you understand the intracancies it will allow you to understand the motivation behind issues such as lifetimes, unsafe code, compiler optimizations and other topics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>test test 3</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="constant"><a class="header" href="#constant">Constant</a></h1>
<p>In this part we will explore the Constant part of the rust program. This section of the rust program contains the constant data of the program. This contains more than you may intially realize. However this section also has more restrictions on its data than other sections as its the values to this section must be written at compile type. This means the structure of the type all it's data values must be completely calculateable at compile time. Whenever you write a program </p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="heap"><a class="header" href="#heap">Heap</a></h1>
<h2 id="what-is-the-heap"><a class="header" href="#what-is-the-heap">What is the heap?</a></h2>
<h2 id="why-we-use-it"><a class="header" href="#why-we-use-it">Why we use it.</a></h2>
<h2 id="what-is-the-allocator"><a class="header" href="#what-is-the-allocator">What is the Allocator?</a></h2>
<h2 id="custom-allocators"><a class="header" href="#custom-allocators">Custom allocators</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2"><a class="header" href="#chapter-2">Chapter 2</a></h1>
<p>Test Test</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async"><a class="header" href="#async">async</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffis"><a class="header" href="#ffis">FFIs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miri"><a class="header" href="#miri">miri</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constant-eval"><a class="header" href="#constant-eval">constant eval</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="higher-kindeness"><a class="header" href="#higher-kindeness">Higher kindeness</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cows"><a class="header" href="#cows">Cows</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap-1"><a class="header" href="#heap-1">Heap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implement-box"><a class="header" href="#implement-box">Implement Box</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implement-vec"><a class="header" href="#implement-vec">Implement Vec</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interior-mutability"><a class="header" href="#interior-mutability">Interior Mutability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implement-cell"><a class="header" href="#implement-cell">Implement Cell</a></h1>
<p>In this chapter we will implement our own version of the cell type from the std. TODO link.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implement-rc"><a class="header" href="#implement-rc">Implement Rc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implement-refcell"><a class="header" href="#implement-refcell">Implement Refcell</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-mutex"><a class="header" href="#implementing-a-mutex">Implementing A Mutex</a></h1>
<p>TODO check title and section titles make sense.
TODO filename vs html
TODO add listings to each import
TODO pub code
TODO add section for other functions
TODO check each import is code to library code
TODO mention why all in one file
TODO describe algorithm and recursive or not</p>
<p>In this chapter we will be implementing a <code>Mutex</code> and it will be a messy complicated journey.
On this journey we will explore <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>Atomics</code></a>, the <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> and poisoning.</p>
<p>The <code>Mutex</code> guards a value while allowing access to the value from multiple threads. It does this by using thread synchronization to only allow access to the variable from one thread at a time.</p>
<p>Modern implementations of the <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, such as those found in the Rust standard library, involve complex locking mechanisms and take advantage of OS specific features.
We however will not be taking advantage of these as they are beyond the scope of this chapter and irrelevant for our discussion.
Our Mutex will instead just use Atomics to synchronize which will work on all platforms for which Atomics on <code>u8</code> are implemented.
In addition to further simplify our implementation threads will spin (endlessly loop) while the Mutex is unavailable.</p>
<p>Simple spinlocks are an extremely poor method for locking Mutexes and come with several harmful side effects.
To learn more about this check out TODO link</p>
<p>This unfortunately that means that the Mutex we create here is unsuitable for real use but it will still enlighten us the important issues.</p>
<p>Our implementation will in the early sections will have trait bounds <code>!Sync</code>, <code>!Send</code> and <code>Sized</code>.
As we move through the chapter these bounds we be analysed and possibly removed in our final implementation.</p>
<p>So lets get started.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial-layout"><a class="header" href="#initial-layout">Initial Layout</a></h1>
<p>In this section we will create an initial skeleton for our Mutex.</p>
<p>A little thought leads us to this basic structure:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mutex&lt;T : Sized&gt; {
    lock_mech : LockMech,
    data : T
}

struct LockMech;
<span class="boring">}
</span></code></pre></pre>
<p>The data field shall hold our data while the <code>LockMech</code> struct will handle access control. It will, as previously discussed only allow one thread access to the data at any one time and spin while waiting. The <code>LockMech</code> struct is also the element for which we could use conditional compilation to take advantage of each platforms features and is how the std actually works.</p>
<p>Our Mutex will also need some methods:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>
#![feature(negative_impls)]

<span class="boring">fn main() {
</span>pub struct Mutex&lt;T : Sized&gt; {
    lock_mech : LockMech,
    data : T,
}

struct LockMech;

impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}

impl&lt;T:Sized&gt; Mutex&lt;T&gt; {

    /// Create a mutex for some data.
    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
        todo!()
    }

    /// Tries to lock, spins until we get access to data.
    fn lock(&amp;mut self) -&gt; &amp;mut T {
        todo!()
    }

    /// Tries to lock but returns with None if unable to get immediate access 
    fn try_lock(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        todo!()
    }

    /// Consume the mutex and return the inner T.
    fn into_inner(self) -&gt; T {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This gives us the core functionality expected from a Mutex. This should be enough for our purpose and can easily be expanded to give further functionality.</p>
<p>TODO  Sized, pub</p>
<p>We can also create the following methods for our <code>LockMech</code> struct.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LockMech;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;mut self) -&gt; &amp;mut T {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        &amp;mut self.data
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(&amp;mut self.data)
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl LockMech {

    /// Create a LockMech.
    fn new() -&gt; LockMech  {
        todo!()
    }

    /// Tries to lock, spins until we get access to data.
    fn lock(&amp;mut self) {
        todo!()
    }

    /// Tries to lock but returns with False if unable to
    /// get immediate access. If it can get the lock we return
    /// True.
    fn try_lock(&amp;mut self) -&gt; bool {
        todo!()
    }

    /// Unlocks the lock.
    fn unlock(&amp;mut self) {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now using these functions we can now complete the bodies of our associated methods on the Mutex struct.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LockMech;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span>impl&lt;T:Sized&gt; Mutex&lt;T&gt; {

    /// Create a mutex for some data.
    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
        Mutex{
            lock_mech : LockMech::new(),
            data,
        }
    }

    /// Tries to lock, spins until we get access to data.
    fn lock(&amp;mut self) -&gt; &amp;mut T {
        self.lock_mech.lock();
        &amp;mut self.data
    }

    /// Tries to lock but returns with None if unable to get immediate access 
    fn try_lock(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        if self.lock_mech.try_lock() {
            Some(&amp;mut self.data)
        }
        else {
            None
        }
    }

    /// Consume the mutex and return the inner T.
    fn into_inner(self) -&gt; T {
        self.data
    }
}
<span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech  {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;mut self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;mut self) -&gt; bool {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;mut self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Our Mutex is already looking good and we have only just begun. However we already have several problems to address that we should fix before go further.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-mutex-guard"><a class="header" href="#implementing-mutex-guard">Implementing Mutex Guard</a></h1>
<p>The first issue being rather simple. Our lock functions lock the <code>Mutex</code> and return a mutable reference to our data which should work fine once we implement our <code>LockMech</code>. The problem is however that we never unlock the lock once we are done making changes to the inner data.</p>
<p>This problem is relatively common and has a well known solution is to simply return a new struct called a <code>MutexGuard</code> from our locking functions. If we implement traits <code>Deref</code> and <code>DerefMut</code> on the <code>MutexGuard</code> the user will be able to treat it like a reference to the inner data.
By also implementing the <code>drop</code> trait to unlock the <code>Mutex</code> when we are done.</p>
<p>So lets implement it.</p>
<p>We create the <code>MutexGuard</code> and its associated methods:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">
</span>use std::ops::{Drop, Deref, DerefMut};

// --snip--

<span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LockMech;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">//  --snip--
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : data,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a mut self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">//  --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech  {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;mut self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;mut self) -&gt; bool {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;mut self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span>pub struct MutexGuard&lt;'a, T:Sized&gt; {
    mu : &amp;'a mut Mutex&lt;T&gt;,
}

impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}

impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
    fn new(mu : &amp;'a mut Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
        MutexGuard {
            mu
        }
    }
}

impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
    fn drop(&amp;mut self) {
        self.mu.lock_mech.unlock();
    }
}

impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp; self.mu.data
    }
}

impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.mu.data
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And we alter the methods on the <code>Mutex</code> to return a <code>MutexGuard</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LockMech;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span>impl&lt;T:Sized&gt; Mutex&lt;T&gt; {

//  --snip--

<span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : data,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    /// Tries to lock, spins until we get access to data.
    fn lock&lt;'a&gt;(&amp;'a mut self) -&gt; MutexGuard&lt;'a, T&gt; {
        self.lock_mech.lock();
        MutexGuard::new(self)
    }

    /// Tries to lock but returns with None if unable to get immediate access 
    fn try_lock&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
        if self.lock_mech.try_lock() {
            Some(MutexGuard::new(self))
        }
        else {
            None
        }
    }

//  --snip--

<span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech  {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;mut self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;mut self) -&gt; bool {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;mut self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">pub struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a mut Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn new(mu : &amp;'a mut Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; self.mu.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut self.mu.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>That was relatively simple so lets move on to the next problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-our-mutex-using-an-unsafecell"><a class="header" href="#implementing-our-mutex-using-an-unsafecell">Implementing our Mutex using an UnsafeCell</a></h1>
<p>The second issue is much more complicated.
Our Mutex is going to be accessed from multiple places possibly at the same time as such we are going to have problems with using <code>&amp;mut self</code> at each call site.</p>
<p>If we try and give out a <code>&amp;mut self</code> to each thread, the compiler will correctly stop us from having multiple mutable references to the same element.</p>
<p>In order to solve this we will change all the previous functions to only require a <code>&amp;self</code> instead.
The compiler will let us give out multiple shared references quite happily.
This will give us:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LockMech;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : data,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    /// Tries to lock, spins until we get access to data.
    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
        self.lock_mech.lock();
        MutexGuard::new(self)
    }

    /// Tries to lock but returns with None if unable to get immediate access 
    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
        if self.lock_mech.try_lock() {
            Some(MutexGuard::new(self))
        }
        else {
            None
        }
    }
<span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech  {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;mut self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;mut self) -&gt; bool {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;mut self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a mut Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn new(mu : &amp;'a mut Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; self.mu.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut self.mu.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>TODO set doesn't compiler on import in mdbook md text when we test</p>
<p>This however also gives us a bunch of compiler errors in our other methods:</p>
<p>TODO compiler error</p>
<pre><code class="language-console">hhhh
</code></pre>
<p>So we need to make the same change in the functions of our internal structs.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LockMech;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : data,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>
impl LockMech {

    /// Create a LockMech.
    fn new() -&gt; LockMech  {
        todo!()
    }

    /// Tries to lock, spins until we get access to data.
    fn lock(&amp; self) {
        todo!()
    }

    /// Tries to lock but returns with False if unable to
    /// get immediate access. If it can get the lock we return
    /// True.
    fn try_lock(&amp; self) -&gt; bool {
        todo!()
    }

    /// Unlocks the lock.
    fn unlock(&amp; self) {
        todo!()
    }
}


struct MutexGuard&lt;'a, T:Sized&gt; {
    mu : &amp;'a Mutex&lt;T&gt;,
}

impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}

impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
        MutexGuard {
            mu
        }
    }
}

<span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; self.mu.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut self.mu.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>However this once more creates another new problem.
The compiler nicely stops us from making any changes to our internal structs as we no longer have a mutable reference to them.
But we can't get a mutable reference as our <code>MutexGuard</code> only has a shared reference to our <code>Mutex</code>.</p>
<pre><code class="language-console">dddd
</code></pre>
<p>So we need some way of getting mutable access from a shared reference.</p>
<p>Luckily there is a solution and that is the <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;T&gt;</code></a>.
The <code>UnsafeCell&lt;T&gt;</code> is the core compiler primitive when it comes to interior mutability.
All types implementing interior mutability are using the UnsafeCell at the lowest level.
It may look complicated to begin with but all it is a wrapper around a value with the additional aspect that it disables several compiler optimizations.
The docs for the <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html">UnsafeCell</a> give a fuller picture while all we need to understand is that the <code>UnsafeCell&lt;T&gt;</code> lets us take a <code>&amp;UnsafeCell&lt;T&gt;</code> to a <code>*mut T</code> which we can then turn into a <code>&amp;mut T</code> via unsafe code. TODO mention other ways UnsafeCell works such as send sync behavior.
It also gives us the correct behavior from the drop checker and the correct variance, which we explain later. TODO which is.</p>
<p>So lets change our <code>Mutex&lt;T&gt;</code>'s data field to <code>UnsafeCell&lt;T&gt;</code> to take advantage of this behavior.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span>use std::cell::UnsafeCell;

pub struct Mutex&lt;T : Sized&gt; {
    lock_mech : LockMech,
    data : UnsafeCell&lt;T&gt;,
}
<span class="boring">
</span><span class="boring">struct LockMech;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data.into_inner()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech  {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp; of MutexGuard ensures we have shared access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp; *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp;mut of MutexGuard ensures we have unique access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp;mut *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>And we also make changes to the appropriate functions:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LockMech;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span>impl&lt;T:Sized&gt; Mutex&lt;T&gt; {

    /// Create a mutex for some data.
    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
        Mutex{
            lock_mech : LockMech::new(),
            data : UnsafeCell::new(data),
        }
    }

    /// Tries to lock, spins until we get access to data.
    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
        self.lock_mech.lock();
        MutexGuard::new(self)
    }

    /// Tries to lock but returns with None if unable to get immediate access 
    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
        if self.lock_mech.try_lock() {
            Some(MutexGuard::new(self))
        }
        else {
            None
        }
    }

    /// Consume the mutex and return the inner T.
    fn into_inner(self) -&gt; T {
        self.data.into_inner()
    }
}
<span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech  {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp; of MutexGuard ensures we have shared access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp; *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp;mut of MutexGuard ensures we have unique access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp;mut *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>Also we need to alter the deref functions for the <code>MutexGuard</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LockMech;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data.into_inner()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech  {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        // SAFETY: safe as only one MutexGuard at any time and
        // &amp; of MutexGuard ensures we have shared access
        // Also function lifetimes ensure we can't use after we
        // lose the MutexGuard
        unsafe{&amp; *self.mu.data.get()}
    }
}

impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        // SAFETY: safe as only one MutexGuard at any time and
        // &amp;mut of MutexGuard ensures we have unique access
        // Also function lifetimes ensure we can't use after we
        // lose the MutexGuard
        unsafe{&amp;mut *self.mu.data.get()}
    }
}
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>With this we can give safe mutable access to the inner data via our Mutex.</p>
<h2 id="variance"><a class="header" href="#variance">Variance</a></h2>
<p>TODO MutexGuard 'a and Mutex</p>
<p>For the <code>T</code> in <code>Mutex&lt;T&gt;</code> and <code>MutexGuard&lt;'a,T&gt;</code> we need it to be invariant.
This can be seen as we can get a <code>&amp;mut T</code> from the <code>Mutex&lt;T&gt;</code> and <code>MutexGuard&lt;'a,T&gt;</code> so it must at least have the same variance, which is invariant, or stricter.
But as invariance is the strictest possible variance it must be invariant. This is already given by the <code>UnsafeCell&lt;T&gt;</code> so we need to make no changes.</p>
<p>Now we consider the <code>'a</code> in the <code>MutexGuard&lt;'a,T&gt;</code>.
This lifetime is linked to the lifetime of the MutexGuard and not the lifetime of the references it gives out.
It is sound to give a longer lived <code>MutexGuard&lt;'a,T&gt;</code> when we expect a shorter lived <code>MutexGuard&lt;'a,T&gt;</code>, which is covariance.
It is unsound the other way however.
Luckily <code>'a</code> is already covariant which it gets from its <code>&amp;'a Mutex&lt;T&gt;</code>, so we again need to do no more.</p>
<h2 id="dropcheck"><a class="header" href="#dropcheck">Dropcheck</a></h2>
<p>TODO MutexGuard 'a and Mutex, check</p>
<p>The Mutex owns <code>T</code> so we need to let the compiler know this. The <code>UnsafeCell&lt;T&gt;</code> takes care of this for us.</p>
<p>The <code>MutexGuard&lt;'a,T&gt;</code> however only has a reference to the <code>T</code>.
Once again we need to do nothing as the compiler can work this out due to <code>&amp;'a Mutex&lt;T&gt;</code> in the <code>MutexGuard&lt;'a,T&gt;</code>. TODO check</p>
<p>Now with all that out of the way we can get back and complete our locking mechanism.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="locking-our-mutex"><a class="header" href="#locking-our-mutex">Locking our mutex</a></h1>
<p>The time has now come to implement our actual locking mechanism in the <code>LockMech</code> struct.</p>
<p>As mentioned at the beginning of the chapter, modern OSs offer features to make the locking mechanism much more efficient.
Unfortunately in order to implement such a lock we would be required to get involved with the various APIs each OS and the hardware they expose. This however is outside the scope of the chapter, which is to understand the safety concerns when creating our own types and not the intricacies of OS design.
If you want to examine how we can create a Mutex using these features you can check the implementations in the standard library.</p>
<p>Our <code>Mutex</code> will utilise an <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html"><code>AtomicBool</code></a> which has been exposed by Rust's std. This type is only available on platforms that support atomic loads and stores of <code>u8</code>. This should cover most platforms.</p>
<h2 id="atomics"><a class="header" href="#atomics">Atomics</a></h2>
<p>The <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html"><code>AtomicBool</code></a> will be the core of our lock. When no one has a <code>MutexGuard</code> the bool will be <code>false</code> and when one exists it will be <code>true</code>. So let's import the appropriate modules and alter the <code>LockMech</code> struct.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span>use std::sync::atomic::{AtomicBool, Ordering};
use std::hint;

// --snip--

<span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data.into_inner()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span>struct LockMech {
    locked : AtomicBool
}
<span class="boring">
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new()-&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(false)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock() {
</span><span class="boring">            hint::spin_loop();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with false if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// true.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        !self.locked.swap(true, Ordering::Acquire)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.store(false, Ordering::Release)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;'b self) -&gt; &amp;'b Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp; of MutexGuard ensures we have shared access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp; *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;'b mut self) -&gt; &amp;'b mut Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp;mut of MutexGuard ensures we have unique access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp;mut *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>For the <code>fn new() -&gt; LockMech</code> method we will simply create an <code>AtomicBool</code> with the initial value <code>false</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span><span class="boring">use std::sync::atomic::{AtomicBool, Ordering};
</span><span class="boring">use std::hint;
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data.into_inner()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct LockMech {
</span><span class="boring">    locked : AtomicBool
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span>    /// Create a LockMech.
    fn new()-&gt; LockMech {
        LockMech {
            locked : AtomicBool::new(false)
        }
    }
<span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock() {
</span><span class="boring">            hint::spin_loop();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with false if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// true.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        !self.locked.swap(true, Ordering::Acquire)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.store(false, Ordering::Release)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;'b self) -&gt; &amp;'b Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp; of MutexGuard ensures we have shared access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp; *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;'b mut self) -&gt; &amp;'b mut Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp;mut of MutexGuard ensures we have unique access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp;mut *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>fn unlock(&amp;self)</code> function is also relatively simple as we will simply use the <code>fn store(&amp;self, val: bool, order: Ordering)</code> method with <code>val</code> set to <code>false</code> from the AtomicBool library to change it from <code>true</code> to <code>false</code>.
We will talk about the ordering in a moment.
TODO change ordering</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span><span class="boring">use std::sync::atomic::{AtomicBool, Ordering};
</span><span class="boring">use std::hint;
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data.into_inner()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct LockMech {
</span><span class="boring">    locked : AtomicBool
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new()-&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(false)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock() {
</span><span class="boring">            hint::spin_loop();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with false if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// true.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        !self.locked.swap(true, Ordering::Acquire)
</span><span class="boring">    }
</span><span class="boring">
</span>    /// Unlocks the lock.
    fn unlock(&amp;self) {
        self.locked.store(false, Ordering::Release)
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;'b self) -&gt; &amp;'b Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp; of MutexGuard ensures we have shared access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp; *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;'b mut self) -&gt; &amp;'b mut Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp;mut of MutexGuard ensures we have unique access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp;mut *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Now we need to complete the lock functions.
The lock functions we need to be more complex as the methods must read the bool and if the bool is <code>false</code> we set it to <code>true</code> then alert us to this action but if the bool is <code>true</code> then we do nothing and alert ourselves to the fact all of which must be done atomically.</p>
<p>For <code>fn lock(&amp;self)</code> we will repeatedly call the <code>fn try_lock(&amp;self) -&gt; bool</code> function in a loop and only return when <code>try_lock</code> returns <code>true</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span><span class="boring">use std::sync::atomic::{AtomicBool, Ordering};
</span><span class="boring">use std::hint;
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data.into_inner()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct LockMech {
</span><span class="boring">    locked : AtomicBool
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new()-&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(false)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    /// Tries to lock, spins until we get access to data.
    fn lock(&amp;self) {
        while !self.try_lock() {
            hint::spin_loop();
        }
    }
<span class="boring">
</span><span class="boring">    /// Tries to lock but returns with false if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// true.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        !self.locked.swap(true, Ordering::Acquire)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.store(false, Ordering::Release)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;'b self) -&gt; &amp;'b Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp; of MutexGuard ensures we have shared access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp; *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;'b mut self) -&gt; &amp;'b mut Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp;mut of MutexGuard ensures we have unique access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp;mut *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>TODO add hint::spin_lock() and link</p>
<p>The function <code>std::hint::spin_loop()</code> is a standard library function that signals to the processor that it is running in a busy-wait spin-loop if the capability is available on the target platform and does nothing if it is not.</p>
<p>Now we just need to complete the <code>fn try_lock(&amp;self) -&gt; bool</code> function.
The <code>fn swap(&amp;self, val: bool, order: Ordering) -&gt; bool</code> from <code>AtomicBool</code>'s library with <code>val</code> set to <code>true</code> will give us the correct behavior.</p>
<p>If the Mutex is not locked then the <code>LockMech</code>'s bool is <code>false</code>, <code>swap</code> will change the value to <code>true</code> and return <code>false</code>. Hence acquiring the lock and by taking the logical not of the output of <code>swap</code> we get our desired output.</p>
<p>If the Mutex is locked then the <code>LockMech</code>'s bool is <code>true</code>, <code>swap</code> will do nothing to the value, so it remains <code>true</code> and the <code>swap</code> function returns <code>true</code>. So just by taking the logical not of this we can finish our <code>try_lock</code> method.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span><span class="boring">use std::sync::atomic::{AtomicBool, Ordering};
</span><span class="boring">use std::hint;
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data.into_inner()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct LockMech {
</span><span class="boring">    locked : AtomicBool
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new()-&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(false)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock() {
</span><span class="boring">            hint::spin_loop();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    /// Tries to lock but returns with false if unable to
    /// get immediate access. If it can get the lock we return
    /// true.
    fn try_lock(&amp;self) -&gt; bool {
        !self.locked.swap(true, Ordering::Acquire)
    }
<span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.store(false, Ordering::Release)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;'b self) -&gt; &amp;'b Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp; of MutexGuard ensures we have shared access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp; *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;'b mut self) -&gt; &amp;'b mut Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp;mut of MutexGuard ensures we have unique access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp;mut *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>TODO change to swap and size_hint() and spin lock</p>
<h2 id="orderings"><a class="header" href="#orderings">Orderings</a></h2>
<p>TODO orderings</p>
<p>We this with have now finished the locking mechanism for the Mutex. With this the core functionality of the Mutex is complete. We now need to implement the appropriate traits for our Mutex.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-auto-traits"><a class="header" href="#implementing-auto-traits">Implementing Auto Traits</a></h1>
<p>We have implemented the core functionality of our <code>Mutex</code>. We can safely lock and access the inner data. As such it has now come time to examine the <code>Sync</code>, <code>Send</code> and <code>?Sized</code> traits.</p>
<h2 id="sync-and-send"><a class="header" href="#sync-and-send">Sync and Send</a></h2>
<p>We will first consider the <code>Sync</code> and <code>Send</code> trait</p>
<h3 id="mutex"><a class="header" href="#mutex">Mutex</a></h3>
<p>With a little thought, we see that we can't just give blanket implementations of <code>Send</code> and <code>Sync</code> for <code>Mutex&lt;T&gt;</code> with any <code>T</code>. This is becomes clear when you consider the case when <code>T</code> is a <code>Rc&lt;U&gt;</code>. The <code>Mutex</code> would allow us to create an <code>Rc</code> in two different threads.</p>
<p>Looking at the access the <code>Mutex&lt;T&gt;</code>and the <code>&amp;Mutex&lt;T&gt;</code> give us the right idea.</p>
<p>The <code>Mutex&lt;T&gt;</code> effectively owns the type <code>T</code> and gives mutable access to <code>T</code>. This leads us to the fact that if <code>T</code> is <code>Send</code> then so is the <code>Mutex&lt;T&gt;</code>.
However if <code>T</code> is just <code>Sync</code> then this is not enough as we can see if we consider the case where we wrap such a <code>T</code> in a <code>Mutex&lt;T&gt;</code>, transfer that across the boundary then use the <code>into_inner</code> method to get the inner data. This would allow us to illegal take any <code>T:Sync + !Send</code> across boundaries despite the fact that <code>T</code> is not <code>Send</code>.</p>
<p>The <code>&amp;Mutex&lt;T&gt;</code> gives mutable and shared access, via a <code>MutexGuard</code>, to <code>T</code>. This tells us that just knowing that <code>T</code> is <code>Sync</code> is not enough to deduce that <code>&amp;Mutex&lt;T&gt;</code> can cross thread boundaries. Instead, by the same reasoning, knowing that <code>T</code> is <code>Send</code> is enough for <code>&amp;Mutex&lt;T&gt;</code> to be safe to cross thread boundaries. i.e. <code>Mutex&lt;T&gt;</code> is <code>Sync</code> if and only if <code>T</code> is <code>Send</code>.</p>
<p>The above reasoning is summarized in the table below TODO table.</p>
<p>And we can alter are code to reflect this.</p>
<p>TODO code, table</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span><span class="boring">use std::sync::atomic::{AtomicBool, Ordering};
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T : !Send&gt; !Send for Mutex&lt;T&gt; {}
impl&lt;T : !Send&gt; !Sync for Mutex&lt;T&gt; {}
unsafe impl&lt;T : Send&gt; Sync for Mutex&lt;T&gt; {}
unsafe impl&lt;T : Send&gt; Send for Mutex&lt;T&gt; {}
<span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data.into_inner()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct LockMech {
</span><span class="boring">    locked : AtomicBool
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new()-&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(false)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock() {}
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        //TODO check me, change func
</span><span class="boring">        !self.locked.fetch_or(true, Ordering::SeqCst)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">//TODO should this be runnable and others, CHECK ALL ORDERINGS
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.store(false, Ordering::SeqCst)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">//Question over send and poisoning
</span><span class="boring">impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">impl&lt;'a, T : !Sync&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">unsafe impl&lt;'a, T : Sync&gt; Sync for MutexGuard&lt;'a,T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp; of MutexGuard ensures we have shared access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp; *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp;mut of MutexGuard ensures we have unique access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp;mut *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>TODO atomicbool thread safe? explain in all cases</p>
<h3 id="mutexguard"><a class="header" href="#mutexguard">MutexGuard</a></h3>
<p>The issue of <code>Sync</code> and <code>Send</code> however is not quite don, we need to consider the same question for the MutexGuard.</p>
<p>While considering whether the <code>MutexGuard&lt;'a,T&gt;</code> itself can be moved across thread boundaries we only need to consider when <code>T</code> is <code>Send</code> as it quickly follows from our earlier reasoning in the <code>&amp;Mutex</code> case.
This is because moving a <code>&amp;Mutex&lt;T&gt;</code> across the boundary then creating a <code>MutexGuard&lt;'a, T&gt;</code> is equivalent to creating a <code>MutexGuard&lt;'a,T&gt;</code> in the original thread and moving that across thread boundaries.
Now in the case that <code>T</code> is <code>Send</code> it is enough to deduce that it is safe to move <code>MutexGuard&lt;'a, T&gt;</code> across thread boundaries. This is because moving the <code>MutexGuard&lt;'a,T&gt;</code> across the boundaries is logically equivalent to moving <code>T</code> across the boundaries and moving the <code>T</code> back to the original thread when we drop the <code>MutexGuard&lt;'a,T&gt;</code> which is ensured to be safe when <code>T</code> is <code>Send</code>.</p>
<p>Now let us consider whether <code>&amp;MutexGuard&lt;'a,T&gt;</code> is safe to move across thread boundaries. The methods on <code>&amp;MutexGuard&lt;'a,T&gt;</code> can only give us a shared reference to <code>T</code>. As such <code>&amp;MutexGuard&lt;'a,T&gt;</code> is safe to move across thread boundaries. In other words <code>MutexGuard&lt;'a,T&gt;</code> is <code>Sync</code> if and only if <code>T</code> is <code>Sync</code>.</p>
<p>This is again expressed in the table below:</p>
<p>TODO table</p>
<p>Now let us change the code to reflect this:</p>
<p>TODO Check this with example trait bounds as maybe auto derived and not in docs. Tables</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span><span class="boring">use std::ops::{Drop, Deref, DerefMut};
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span><span class="boring">use std::sync::atomic::{AtomicBool, Ordering};
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T : Sized&gt; {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T : !Send&gt; !Send for Mutex&lt;T&gt; {}
</span><span class="boring">impl&lt;T : !Send&gt; !Sync for Mutex&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T : Send&gt; Sync for Mutex&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T : Send&gt; Send for Mutex&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock&lt;'a&gt;(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        MutexGuard::new(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock&lt;'a&gt;(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            Some(MutexGuard::new(self))
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data.into_inner()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct LockMech {
</span><span class="boring">    locked : AtomicBool
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new()-&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(false)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock() {}
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        //TODO check me, change func
</span><span class="boring">        !self.locked.fetch_or(true, Ordering::SeqCst)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">//TODO should this be runnable and others, CHECK ALL ORDERINGS
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.store(false, Ordering::SeqCst)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>//Question over send and poisoning
impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt; {}
impl&lt;'a, T : !Sync&gt; !Sync for MutexGuard&lt;'a,T&gt; {}
unsafe impl&lt;'a, T : Sync&gt; Sync for MutexGuard&lt;'a,T&gt; {}
<span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp; of MutexGuard ensures we have shared access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp; *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        // SAFETY: safe as only one MutexGuard at any time and
</span><span class="boring">        // &amp;mut of MutexGuard ensures we have unique access
</span><span class="boring">        // Also function lifetimes ensure we can't use after we
</span><span class="boring">        // lose the MutexGuard
</span><span class="boring">        unsafe{&amp;mut *self.mu.data.get()}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="sized"><a class="header" href="#sized">Sized</a></h2>
<h3 id="mutex-1"><a class="header" href="#mutex-1">Mutex</a></h3>
<h3 id="mutexguard-1"><a class="header" href="#mutexguard-1">MutexGuard</a></h3>
<h2 id="catch-unwind-and-ref-catch-unwind"><a class="header" href="#catch-unwind-and-ref-catch-unwind">Catch Unwind and Ref Catch Unwind</a></h2>
<h3 id="mutex-2"><a class="header" href="#mutex-2">Mutex</a></h3>
<h3 id="mutexguard-2"><a class="header" href="#mutexguard-2">MutexGuard</a></h3>
<h2 id="pin"><a class="header" href="#pin">Pin</a></h2>
<h3 id="mutex-3"><a class="header" href="#mutex-3">Mutex</a></h3>
<h3 id="mutexguard-3"><a class="header" href="#mutexguard-3">MutexGuard</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review"><a class="header" href="#review">Review</a></h1>
<p>TODO unwind safe, ref unwind safe, unpin TODO Talk about unsafe code how little there is.</p>
<p>We now have a fully working Mutex. It can allow safe access to values from multiple threads. TODO expand</p>
<p>We have this code: TODO code</p>
<p>While this could be used with safely TODO check there are still some issues to address, namely mem::forget and poisoning. TODO rust check name</p>
<p>The mem::forget TODO rusty check name is simple to reason about. If any of the MutexGuard the Mutex will simply never unlock and just leak memory.</p>
<p>TODO Poisoning of itself why can't
The issue with poisoning is much more interesting and will lead to informative discussion. So lets implement guards against it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poisoning"><a class="header" href="#poisoning">Poisoning</a></h1>
<p>The issue is what happens if the user code panics while its making changes to the inner data it can result in the data being left in an incoherent state.
We can implement mechanisms in order to alert the user if this happens. At the moment whether to include this aspect is included in the std library, at the time of writing this, is under debate. TODO check, link, why debate
TODO minimal panic safe</p>
<h2 id="problem-and-solution"><a class="header" href="#problem-and-solution">Problem and Solution</a></h2>
<p>The problem with our code is what happens if the user code panics while altering the inner data. This can result in the inner data being placed in an inconsistent state. TODO example</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Implementation of this will require us to know when the thread we are currently in is panicking. To do this we will make use of the std function thread::panicking() TODO rusty. This function returns True if the current thread is panicking and False otherwise.</p>
<p>If when the MutexGuard is dropped we check if the thread is panicking. If it is we set a flag on the Mutex to note such a fact. Then when future threads try to access we need to notify them that the data has been poisoned and we need to do so while maintaining our safety guarantees.</p>
<p>In order to implement this we will first need to add an AtomicBool to the Mutex that tracks whether the inner data is poisoned or not. TODO Why AtomicBool</p>
<p>TODO add AtomicBool and change setup funcs</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">compiler_error!(ensure sized , past are changed )
</span><span class="boring">
</span>pub struct Mutex&lt;T&gt; : Sized {
    lock_mech : LockMech,
    data : UnsafeCell&lt;T&gt;,
    poison : AtomicBool,
}
<span class="boring">
</span><span class="boring">Unsafe impl&lt;T : !Send&gt; !Send, !Sync for Mutex&lt;T&gt;
</span><span class="boring">Unsafe impl&lt;T : Send&gt; Send, Sync for Mutex&lt;T&gt;
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">            poison : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        if self.poison.get() == True {
</span><span class="boring">            panic!()
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            MutexGuard::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            if self.poison.get() == True {
</span><span class="boring">                panic!()
</span><span class="boring">            }
</span><span class="boring">            else {
</span><span class="boring">                Some(MutexGuard::new(self))
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">    struct LockMech {
</span><span class="boring">        locked : AtomicBool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        self.locked.compare_and_swap(&amp;self, False, True, order: Ordering)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.set(False, Ordering)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">//Question over send and poisoning
</span><span class="boring">Unsafe impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : !Sync&gt; !Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : Sync&gt; Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        if thread::panicking()
</span><span class="boring">        {
</span><span class="boring">            self.mu.poison.set(True);
</span><span class="boring">        }
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">compiler_error!(ensure sized , past are changed )
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T&gt; : Sized {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">    poison : AtomicBool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">Unsafe impl&lt;T : !Send&gt; !Send, !Sync for Mutex&lt;T&gt;
</span><span class="boring">Unsafe impl&lt;T : Send&gt; Send, Sync for Mutex&lt;T&gt;
</span><span class="boring">
</span>impl&lt;T:Sized&gt; Mutex&lt;T&gt; {

    /// Create a mutex for some data.
    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
        Mutex{
            lock_mech : LockMech::new(),
            data : UnsafeCell::new(data),
            poison : AtomicBool::new(False),
        }
    }

    /// Tries to lock, spins until we get access to data.
    fn lock(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
        self.lock_mech.lock();
        if self.poison.get() == True {
            panic!()
        }
        else {
            MutexGuard::new(self)
        }
    }

    /// Tries to lock but returns with None if unable to get immediate access 
    fn try_lock(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
        if self.lock_mech.try_lock() {
            if self.poison.get() == True {
                panic!()
            }
            else {
                Some(MutexGuard::new(self))
            }
        }
        else {
            None
        }
    }

    /// Consume the mutex and return the inner T.
    fn into_inner(self) -&gt; T {
        self.data
    }
}
<span class="boring">
</span><span class="boring">    struct LockMech {
</span><span class="boring">        locked : AtomicBool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        self.locked.compare_and_swap(&amp;self, False, True, order: Ordering)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.set(False, Ordering)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">//Question over send and poisoning
</span><span class="boring">Unsafe impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : !Sync&gt; !Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : Sync&gt; Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        if thread::panicking()
</span><span class="boring">        {
</span><span class="boring">            self.mu.poison.set(True);
</span><span class="boring">        }
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>This should allow us to record if it is possible that the inner data has been poisoned.
And we need to alter the drop TODO rusty method for the MutexGuard to check.</p>
<p>TODO drop method</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">compiler_error!(ensure sized , past are changed )
</span><span class="boring">
</span><span class="boring">pub struct Mutex&lt;T&gt; : Sized {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">    poison : AtomicBool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">Unsafe impl&lt;T : !Send&gt; !Send, !Sync for Mutex&lt;T&gt;
</span><span class="boring">Unsafe impl&lt;T : Send&gt; Send, Sync for Mutex&lt;T&gt;
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">            poison : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        if self.poison.get() == True {
</span><span class="boring">            panic!()
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            MutexGuard::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            if self.poison.get() == True {
</span><span class="boring">                panic!()
</span><span class="boring">            }
</span><span class="boring">            else {
</span><span class="boring">                Some(MutexGuard::new(self))
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">    struct LockMech {
</span><span class="boring">        locked : AtomicBool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        self.locked.compare_and_swap(&amp;self, False, True, order: Ordering)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.set(False, Ordering)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">//Question over send and poisoning
</span><span class="boring">Unsafe impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : !Sync&gt; !Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : Sync&gt; Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
    fn drop(&amp;mut self) {
        if thread::panicking()
        {
            self.mu.poison.set(True);
        }
        self.mu.lock_mech.unlock();
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>And we need to alter the locking functions. We will discuss how we can report this to the user in the next section for now we will just panic!().</p>
<p>TODO locking method change
TODO does it need to be atomic
TODO how do we unset poison flag</p>
<p>There is still one wrinkle with are implementation.</p>
<h2 id="if-threads-are-panicking-already"><a class="header" href="#if-threads-are-panicking-already">If threads are panicking already</a></h2>
<p>The issue is that the panic may have already happened when the thread obtains the MutexGuard. This could have if some types obtain a MutexGuard in their drop trait implementation. This could lead to false positives. So in order to avoid this we will record in our MutexGuard if the thread is panicking when we obtain it, then when we drop the MutexGuard we check if the MutexGuard's flag is set we don't set the poison flag as we were already panicking.
So we set the Mutex poison flag  on the drop of the MutexGuard if the MutexGuard flag is not set and the thead is panicking.</p>
<p>Before we implement this we need to ask ourselves some questions: TODO Double panic, catch_unwind</p>
<p>TODO implement changes to MutexGuard and functions</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">compiler_error!(ensure sized , past are changed )
</span><span class="boring">pub struct Mutex&lt;T&gt; : Sized {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">    poison : AtomicBool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">Unsafe impl&lt;T : !Send&gt; !Send, !Sync for Mutex&lt;T&gt;
</span><span class="boring">Unsafe impl&lt;T : Send&gt; Send, Sync for Mutex&lt;T&gt;
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">            poison : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        if self.poison.get() == True {
</span><span class="boring">            panic!()
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            MutexGuard::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            if self.poison.get() == True {
</span><span class="boring">                panic!()
</span><span class="boring">            }
</span><span class="boring">            else {
</span><span class="boring">                Some(MutexGuard::new(self))
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">    struct LockMech {
</span><span class="boring">        locked : AtomicBool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        self.locked.compare_and_swap(&amp;self, False, True, order: Ordering)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.set(False, Ordering)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span>struct MutexGuard&lt;'a, T:Sized&gt; {
    mu : &amp;'a Mutex&lt;T&gt;,
    guard: bool,
}
<span class="boring">
</span><span class="boring">//Question over send and poisoning
</span><span class="boring">Unsafe impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : !Sync&gt; !Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : Sync&gt; Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu,
</span><span class="boring">            guard: thread::panicking(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        if thread::panicking() &amp;&amp; !self.guard
</span><span class="boring">        {
</span><span class="boring">            self.mu.poison.set(True);
</span><span class="boring">        }
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">compiler_error!(ensure sized , past are changed )
</span><span class="boring">pub struct Mutex&lt;T&gt; : Sized {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">    poison : AtomicBool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">Unsafe impl&lt;T : !Send&gt; !Send, !Sync for Mutex&lt;T&gt;
</span><span class="boring">Unsafe impl&lt;T : Send&gt; Send, Sync for Mutex&lt;T&gt;
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">            poison : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        if self.poison.get() == True {
</span><span class="boring">            panic!()
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            MutexGuard::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            if self.poison.get() == True {
</span><span class="boring">                panic!()
</span><span class="boring">            }
</span><span class="boring">            else {
</span><span class="boring">                Some(MutexGuard::new(self))
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">    struct LockMech {
</span><span class="boring">        locked : AtomicBool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        self.locked.compare_and_swap(&amp;self, False, True, order: Ordering)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.set(False, Ordering)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">    guard: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">//Question over send and poisoning
</span><span class="boring">Unsafe impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : !Sync&gt; !Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : Sync&gt; Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">
</span>impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
        MutexGuard {
            mu,
            guard: thread::panicking(),
        }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        if thread::panicking() &amp;&amp; !self.guard
</span><span class="boring">        {
</span><span class="boring">            self.mu.poison.set(True);
</span><span class="boring">        }
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">compiler_error!(ensure sized , past are changed )
</span><span class="boring">pub struct Mutex&lt;T&gt; : Sized {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">    poison : AtomicBool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">Unsafe impl&lt;T : !Send&gt; !Send, !Sync for Mutex&lt;T&gt;
</span><span class="boring">Unsafe impl&lt;T : Send&gt; Send, Sync for Mutex&lt;T&gt;
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">            poison : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        if self.poison.get() == True {
</span><span class="boring">            panic!()
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            MutexGuard::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            if self.poison.get() == True {
</span><span class="boring">                panic!()
</span><span class="boring">            }
</span><span class="boring">            else {
</span><span class="boring">                Some(MutexGuard::new(self))
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">    struct LockMech {
</span><span class="boring">        locked : AtomicBool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        self.locked.compare_and_swap(&amp;self, False, True, order: Ordering)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.set(False, Ordering)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">    guard: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">//Question over send and poisoning
</span><span class="boring">Unsafe impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : !Sync&gt; !Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">Unsafe impl&lt;'a, T : Sync&gt; Sync for MutexGuard&lt;'a,T&gt;
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu,
</span><span class="boring">            guard: thread::panicking(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
    fn drop(&amp;mut self) {
        if thread::panicking() &amp;&amp; !self.guard
        {
            self.mu.poison.set(True);
        }
        self.mu.lock_mech.unlock();
    }
}
<span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>TODO Send questions check all correct in previous chapters</p>
<p>We also need the MutexGuard !Send TODO rusty in all cases. This is as we are now storing a thread specific data in the MutexGuard.</p>
<p>TODO make not Send</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">compiler_error!(ensure sized , past are changed )
</span><span class="boring">pub struct Mutex&lt;T&gt; : Sized {
</span><span class="boring">    lock_mech : LockMech,
</span><span class="boring">    data : UnsafeCell&lt;T&gt;,
</span><span class="boring">    poison : AtomicBool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">Unsafe impl&lt;T : !Send&gt; !Send, !Sync for Mutex&lt;T&gt;
</span><span class="boring">Unsafe impl&lt;T : Send&gt; Send, Sync for Mutex&lt;T&gt;
</span><span class="boring">
</span><span class="boring">impl&lt;T:Sized&gt; Mutex&lt;T&gt; {
</span><span class="boring">
</span><span class="boring">    /// Create a mutex for some data.
</span><span class="boring">    fn new(data:T) -&gt; Mutex&lt;T&gt;  {
</span><span class="boring">        Mutex{
</span><span class="boring">            lock_mech : LockMech::new(),
</span><span class="boring">            data : UnsafeCell::new(data),
</span><span class="boring">            poison : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;'a self) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        self.lock_mech.lock();
</span><span class="boring">        if self.poison.get() == True {
</span><span class="boring">            panic!()
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            MutexGuard::new(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with None if unable to get immediate access 
</span><span class="boring">    fn try_lock(&amp;'a self) -&gt; Option&lt;MutexGuard&lt;'a, T&gt;&gt; {
</span><span class="boring">        if self.lock_mech.try_lock() {
</span><span class="boring">            if self.poison.get() == True {
</span><span class="boring">                panic!()
</span><span class="boring">            }
</span><span class="boring">            else {
</span><span class="boring">                Some(MutexGuard::new(self))
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Consume the mutex and return the inner T.
</span><span class="boring">    fn into_inner(self) -&gt; T {
</span><span class="boring">        self.data
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">    struct LockMech {
</span><span class="boring">        locked : AtomicBool,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">impl LockMech {
</span><span class="boring">
</span><span class="boring">    /// Create a LockMech.
</span><span class="boring">    fn new() -&gt; LockMech {
</span><span class="boring">        LockMech {
</span><span class="boring">            locked : AtomicBool::new(False),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    /// Tries to lock, spins until we get access to data.
</span><span class="boring">    fn lock(&amp;self) {
</span><span class="boring">        while !self.try_lock()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Tries to lock but returns with False if unable to
</span><span class="boring">    /// get immediate access. If it can get the lock we return
</span><span class="boring">    /// True.
</span><span class="boring">    fn try_lock(&amp;self) -&gt; bool {
</span><span class="boring">        self.locked.compare_and_swap(&amp;self, False, True, order: Ordering)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Unlocks the lock.
</span><span class="boring">    fn unlock(&amp;self) {
</span><span class="boring">        self.locked.set(False, Ordering)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct MutexGuard&lt;'a, T:Sized&gt; {
</span><span class="boring">    mu : &amp;'a Mutex&lt;T&gt;,
</span><span class="boring">    guard: bool,
</span><span class="boring">}
</span><span class="boring">
</span>//Question over send and poisoning
Unsafe impl&lt;'a, T&gt; !Send for MutexGuard&lt;'a,T&gt;
Unsafe impl&lt;'a, T : !Sync&gt; !Sync for MutexGuard&lt;'a,T&gt;
Unsafe impl&lt;'a, T : Sync&gt; Sync for MutexGuard&lt;'a,T&gt;
<span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn new(mu : &amp;'a Mutex&lt;T&gt;) -&gt; MutexGuard&lt;'a, T&gt; {
</span><span class="boring">        MutexGuard {
</span><span class="boring">            mu,
</span><span class="boring">            guard: thread::panicking(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Drop for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        if thread::panicking() &amp;&amp; !self.guard
</span><span class="boring">        {
</span><span class="boring">            self.mu.poison.set(True);
</span><span class="boring">        }
</span><span class="boring">        self.mu.lock_mech.unlock();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; Deref for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;Self::Target {
</span><span class="boring">        &amp; (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T:Sized&gt; DerefMut for MutexGuard&lt;'a,T&gt; {
</span><span class="boring">    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
</span><span class="boring">        &amp;mut (*self.mu.data.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">}
</span></code></pre></pre>
<p>TODO why safe</p>
<p>TODO safety</p>
<p>We now have protected from poisoning and is now time for us to work out how to tell the user their data is possibly poisoned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poisoning-errors"><a class="header" href="#poisoning-errors">Poisoning errors</a></h1>
<p>We now have implemented the code which will record if the inner data has possibly been poisoned and now need to inform the user about the possibility that the data has been poisoned</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The general plan is to change the output of our Mutex's <code>lock</code> method to return a new type TODO rename<code>LockResult</code> which is an enum with two members <code>MutexGuard</code> and <code>PoisonGuard</code> which is just a wrapper around a <code>MutexGuard</code>.
In the case of <code>try_lock</code> we return a <code>TryLockResult</code> which is an enum with three members <code>WillBlock</code>, <code>PoisonGuard</code> and a <code>MutexGuard</code>.</p>
<p>With this the user can pattern match on the output and respond to the poisoned value in the appropriate way</p>
<p>So lets implement it.</p>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>We can create the <code>PoisonGuard</code> as a simple wrapper quite easily</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="were-done"><a class="header" href="#were-done">We're Done!</a></h1>
<p>We have finally done it! A fully functional Mutex that can sing, dance and manage access to our data from various threads.
We done an awful lot in this chapter. We,ve learnt about Mutexes, Atomics, how to change our code's behavior if our thread is panicking.</p>
<h2 id="full-code"><a class="header" href="#full-code">Full Code</a></h2>
<p>Here is our final code:
TODO add code</p>
<h2 id="extending-our-mutex"><a class="header" href="#extending-our-mutex">Extending Our Mutex</a></h2>
<p>If you desire a challenge you could extend our multiple ways:
TODO list
add associated methods from std's Mutex on our Mutex with reasoning to why it is safe to do so.
make our Mutex OS dependent TODO finish, name</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
